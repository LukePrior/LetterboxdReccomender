<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movie Recommender</title>
    <!-- Use the correct ONNX Runtime Web CDN -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .loading {
            text-align: center;
            color: #666;
        }
        .error {
            color: red;
            background: #ffebee;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            color: green;
            background: #e8f5e8;
            padding: 10px;
            border-radius: 4px;
        }
        input, button {
            padding: 10px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .recommendations {
            margin-top: 20px;
        }
        .movie-item {
            background: white;
            padding: 15px;
            margin: 8px 0;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        .movie-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        .movie-id {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        .movie-score {
            font-size: 12px;
            color: #888;
            margin-top: 2px;
        }
        .letterboxd-section {
            border: 2px solid #00c030;
            background: #f0fff0;
        }
        .letterboxd-films {
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
            background: white;
            padding: 10px;
            border-radius: 4px;
        }
        .letterboxd-film {
            padding: 5px;
            margin: 2px 0;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }
        .matched {
            color: #00c030;
            font-weight: bold;
        }
        .unmatched {
            color: #888;
        }
        .tab-container {
            display: flex;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background: #e0e0e0;
            border: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
        }
        .tab.active {
            background: #007bff;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <h1>Movie Recommender</h1>
    
    <div class="container">
        <h3>Model Status</h3>
        <div id="modelStatus" class="loading">Loading model...</div>
    </div>

    <div class="tab-container">
        <button class="tab active" onclick="switchTab('manual')">Manual Input</button>
        <button class="tab" onclick="switchTab('letterboxd')">Letterboxd User</button>
    </div>

    <div id="manualTab" class="tab-content active">
        <div class="container">
            <h3>Get Recommendations (Manual)</h3>
            <p>Enter movie IDs (comma-separated) from your viewing history:</p>
            <input type="text" id="movieInput" placeholder="e.g., 1,2,3,4,5" style="width: 300px;">
            <button id="predictBtn" onclick="predict()" disabled>Get Recommendations</button>
            
            <div id="recommendations" class="recommendations"></div>
        </div>
    </div>

    <div id="letterboxdTab" class="tab-content">
        <div class="container letterboxd-section">
            <h3>Get Recommendations from Letterboxd</h3>
            <p>Enter a Letterboxd username to fetch their recent films:</p>
            <input type="text" id="letterboxdUsername" placeholder="Enter Letterboxd username" style="width: 300px;">
            <button id="fetchLetterboxdBtn" onclick="fetchLetterboxdFilms()" disabled>Fetch Films</button>
            <button id="predictLetterboxdBtn" onclick="predictFromLetterboxd()" disabled style="display: none;">Get Recommendations</button>
            
            <div id="letterboxdStatus"></div>
            <div id="letterboxdFilms" class="letterboxd-films" style="display: none;"></div>
            <div id="letterboxdRecommendations" class="recommendations"></div>
        </div>
    </div>

    <div class="container">
        <h3>Debug Info</h3>
        <div id="debugInfo"></div>
    </div>

    <script>
        let session = null;
        let metadata = null;
        let movieIdToName = null;
        let movieTitles = {}; // For normalized title to ID mapping (like Python)
        let letterboxdMatchedIds = [];
        
        // Tab switching functionality
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Add active class to selected tab
            event.target.classList.add('active');
        }
        
        // Wait for ONNX Runtime to load
        function waitForOrt() {
            return new Promise((resolve, reject) => {
                if (typeof ort !== 'undefined') {
                    resolve();
                    return;
                }
                
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max
                
                const checkOrt = () => {
                    attempts++;
                    if (typeof ort !== 'undefined') {
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        reject(new Error('ONNX Runtime failed to load'));
                    } else {
                        setTimeout(checkOrt, 100);
                    }
                };
                
                checkOrt();
            });
        }
        
        // Initialize the application
        async function init() {
            try {
                updateStatus('Loading ONNX Runtime...', 'loading');
                
                // Wait for ONNX Runtime to be available
                await waitForOrt();
                
                updateStatus('Loading model metadata...', 'loading');
                
                // Load metadata
                const metadataResponse = await fetch('models/metadata.json');
                if (!metadataResponse.ok) {
                    throw new Error(`Failed to load metadata: ${metadataResponse.status} ${metadataResponse.statusText}`);
                }
                metadata = await metadataResponse.json();
                
                updateStatus('Loading movie names...', 'loading');
                
                // Load movie ID to name mapping
                const movieNamesResponse = await fetch('models/movie_id_to_name.json');
                if (!movieNamesResponse.ok) {
                    throw new Error(`Failed to load movie names: ${movieNamesResponse.status} ${movieNamesResponse.statusText}`);
                }
                const movieNamesData = await movieNamesResponse.json();
                movieIdToName = movieNamesData.data;
                
                // Build normalized title to ID mapping (like Python's movie_titles)
                buildMovieTitlesMapping();
                
                updateStatus('Loading ONNX model...', 'loading');
                
                // Load ONNX model with error handling
                try {
                    session = await ort.InferenceSession.create('models/sasrec_model.onnx', {
                        executionProviders: ['wasm']
                    });
                } catch (modelError) {
                    console.error('Model loading error:', modelError);
                    throw new Error(`Failed to load ONNX model: ${modelError.message}`);
                }
                
                updateStatus('Model loaded successfully!', 'success');
                document.getElementById('predictBtn').disabled = false;
                document.getElementById('fetchLetterboxdBtn').disabled = false;
                
                // Display model info
                displayDebugInfo();
                
            } catch (error) {
                console.error('Error loading model:', error);
                updateStatus(`Error loading model: ${error.message}`, 'error');
            }
        }
        
        // More strict normalize title function
        function normalizeTitle(title) {
            if (!title || typeof title !== 'string') {
                return '';
            }
            
            // Remove year in parentheses at the end (e.g., "Movie Title (2023)" -> "Movie Title")
            let cleaned = title.replace(/\s*\(\d{4}\)\s*$/, '');
            
            // Convert to lowercase, remove special characters, normalize spaces
            let normalized = cleaned.toLowerCase()
                .replace(/[^\w\s]/g, ' ') // Replace special chars with spaces
                .replace(/\s+/g, ' ')     // Normalize multiple spaces to single space
                .trim();
            
            return normalized;
        }

        // Film matching function that mirrors Python's fetch_letterboxd_user_films logic
        function findMovieIdByTitle(filmTitle) {
            if (!movieTitles || !movieIdToName) return null;
            
            // Normalize the input title (Letterboxd title without year)
            const normalizedTitle = normalizeTitle(filmTitle);
            
            // Skip empty normalized titles
            if (!normalizedTitle || normalizedTitle.trim() === '') {
                return null;
            }
            
            // Direct match first (exact match after normalization)
            if (normalizedTitle in movieTitles) {
                return movieTitles[normalizedTitle];
            }
            
            // Fuzzy matching - look for titles that match when years are removed
            for (const [dbTitle, movieId] of Object.entries(movieTitles)) {
                if (titlesSimilar(normalizedTitle, dbTitle, 0.7)) { // Higher threshold for more precision
                    return movieId;
                }
            }
            
            return null;
        }
        
        // Title similarity function with stricter matching
        function titlesSimilar(title1, title2, threshold = 0.7) {
            // Simple Jaccard similarity using words
            const words1 = new Set(title1.split(' ').filter(word => word.length > 1));
            const words2 = new Set(title2.split(' ').filter(word => word.length > 1));
            
            if (words1.size === 0 || words2.size === 0) {
                return false;
            }
            
            // For very short titles, require exact match
            if (words1.size <= 2 && words2.size <= 2) {
                return title1 === title2;
            }
            
            const intersection = new Set([...words1].filter(word => words2.has(word)));
            const union = new Set([...words1, ...words2]);
            
            const similarity = union.size > 0 ? intersection.size / union.size : 0;
            
            return similarity >= threshold;
        }

        function buildMovieTitlesMapping() {
            movieTitles = {};
            if (!movieIdToName) return;
            
            for (const [movieId, title] of Object.entries(movieIdToName)) {
                if (title) {
                    const normalizedTitle = normalizeTitle(title); // This will remove the year
                    if (normalizedTitle && normalizedTitle.trim() !== '') {
                        movieTitles[normalizedTitle] = parseInt(movieId);
                    }
                }
            }
            
            console.log(`Built normalized title mapping for ${Object.keys(movieTitles).length} movies`);
        }
        
        function updateStatus(message, type) {
            const statusDiv = document.getElementById('modelStatus');
            statusDiv.textContent = message;
            statusDiv.className = type;
        }
        
        function updateLetterboxdStatus(message, type) {
            const statusDiv = document.getElementById('letterboxdStatus');
            statusDiv.innerHTML = `<div class="${type}">${message}</div>`;
        }
        
        function displayDebugInfo() {
            const debugDiv = document.getElementById('debugInfo');
            const movieCount = movieIdToName ? Object.keys(movieIdToName).length : 0;
            debugDiv.innerHTML = `
                <p><strong>Model Info:</strong></p>
                <ul>
                    <li>Max sequence length: ${metadata.model_params.max_len}</li>
                    <li>Number of movies: ${metadata.num_movies}</li>
                    <li>Embedding dimension: ${metadata.model_params.embed_dim}</li>
                    <li>Input shape: [${metadata.input_shape.join(', ')}]</li>
                    <li>Output shape: [${metadata.output_shape.join(', ')}]</li>
                    <li>Movie names loaded: ${movieCount} movies</li>
                    <li>Normalized titles: ${Object.keys(movieTitles).length} movies</li>
                    <li>ONNX Runtime loaded: ${typeof ort !== 'undefined' ? 'Yes' : 'No'}</li>
                </ul>
            `;
        }
        
        function getMovieName(movieId) {
            return movieIdToName && movieIdToName[movieId.toString()] 
                ? movieIdToName[movieId.toString()] 
                : `Unknown Movie (ID: ${movieId})`;
        }
        
        // Normalize title function matching Python implementation
        function normalizeTitle(title) {
            // Convert to lowercase, remove special characters, normalize spaces
            let normalized = title.toLowerCase().replace(/[^\w\s]/g, '');
            normalized = normalized.replace(/\s+/g, ' ').trim();
            return normalized;
        }
        
        // Title similarity function matching Python implementation
        function titlesSimilar(title1, title2, threshold = 0.7) {
            // Simple Jaccard similarity using words
            const words1 = new Set(title1.split(' ').filter(word => word.length > 0));
            const words2 = new Set(title2.split(' ').filter(word => word.length > 0));
            
            if (words1.size === 0 || words2.size === 0) {
                return false;
            }
            
            const intersection = new Set([...words1].filter(word => words2.has(word)));
            const union = new Set([...words1, ...words2]);
            
            const similarity = union.size > 0 ? intersection.size / union.size : 0;
            
            return similarity >= threshold;
        }
        
        async function fetchLetterboxdFilms() {
            const username = document.getElementById('letterboxdUsername').value.trim();
            
            if (!username) {
                alert('Please enter a Letterboxd username');
                return;
            }
            
            try {
                document.getElementById('fetchLetterboxdBtn').disabled = true;
                document.getElementById('fetchLetterboxdBtn').textContent = 'Fetching...';
                updateLetterboxdStatus('Fetching films from Letterboxd...', 'loading');
                
                const films = await fetchUserFilms(username);
                
                if (films.length === 0) {
                    updateLetterboxdStatus('No films found for this user', 'error');
                    return;
                }
                
                // Match films with our database - mirroring Python logic
                const matchedFilms = [];
                const unmatchedFilms = [];
                letterboxdMatchedIds = [];
                
                let processedCount = 0;
                let matchedCount = 0;
                
                for (const film of films) {
                    processedCount++;
                    if (matchedCount >= 50) {
                        console.log("Reached limit of 50 matched films, stopping early");
                        break;
                    }
                    
                    const matchedMovieId = findMovieIdByTitle(film.title);
                    
                    if (matchedMovieId) {
                        matchedFilms.push({ ...film, movieId: matchedMovieId });
                        letterboxdMatchedIds.push(matchedMovieId);
                        matchedCount++;
                    } else {
                        unmatchedFilms.push(film);
                    }
                    
                    // Progress indicator for large collections
                    if (processedCount % 50 === 0) {
                        console.log(`Processed ${processedCount} films, matched ${matchedCount} in dataset`);
                    }
                }
                
                console.log(`Fetched ${processedCount} films, ${matchedCount} matched in dataset`);
                
                // Reverse the order and limit to 50 (like Python)
                letterboxdMatchedIds = letterboxdMatchedIds.slice().reverse().slice(0, 50);
                
                // Display results
                displayLetterboxdFilms(matchedFilms, unmatchedFilms);
                
                if (matchedFilms.length > 0) {
                    updateLetterboxdStatus(`Found ${matchedFilms.length} matching films out of ${films.length} total`, 'success');
                    document.getElementById('predictLetterboxdBtn').style.display = 'inline-block';
                    document.getElementById('predictLetterboxdBtn').disabled = false;
                } else {
                    updateLetterboxdStatus('No matching films found in our database', 'error');
                }
                
            } catch (error) {
                console.error('Error fetching Letterboxd films:', error);
                updateLetterboxdStatus(`Error: ${error.message}`, 'error');
            } finally {
                document.getElementById('fetchLetterboxdBtn').disabled = false;
                document.getElementById('fetchLetterboxdBtn').textContent = 'Fetch Films';
            }
        }
        
        async function fetchUserFilms(username) {
            const films = [];
            const maxPages = 3; // Limit to first 3 pages to get ~200 films
            
            for (let page = 1; page <= maxPages; page++) {
                try {
                    const url = `https://letterboxd.com/${username}/films/by/rated-date/page/${page}/`;
                    
                    // Use a CORS proxy service
                    const proxyUrl = `https://corsproxy.io/?url=${encodeURIComponent(url)}`;
                    
                    const response = await fetch(proxyUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const html = await response.text();
                    
                    // Parse HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Find film elements
                    const filmElements = doc.querySelectorAll('img.image');
                    
                    if (filmElements.length === 0) {
                        // No more films on this page
                        break;
                    }
                    
                    for (const img of filmElements) {
                        const title = img.getAttribute('alt');
                        const filmSlug = img.parentElement.getAttribute('data-film-slug');
                        
                        if (title && filmSlug) {
                            films.push({
                                title: title,
                                slug: filmSlug
                            });
                        }
                    }
                    
                    // Limit to 200 films total
                    if (films.length >= 200) {
                        break;
                    }
                    
                    // Add delay between requests to be respectful
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (error) {
                    console.error(`Error fetching page ${page}:`, error);
                    if (page === 1) {
                        throw error; // If first page fails, throw error
                    }
                    break; // For subsequent pages, just stop trying
                }
            }
            
            return films.slice(0, 200); // Ensure we don't exceed 50 films
        }
        
        function displayLetterboxdFilms(matchedFilms, unmatchedFilms) {
            const filmsDiv = document.getElementById('letterboxdFilms');
            
            let html = '<h4>Fetched Films:</h4>';
            
            if (matchedFilms.length > 0) {
                html += '<h5>Matched Films (will be used for recommendations):</h5>';
                matchedFilms.forEach(film => {
                    html += `<div class="letterboxd-film matched">✓ ${film.title} (ID: ${film.movieId})</div>`;
                });
            }
            
            if (unmatchedFilms.length > 0) {
                html += '<h5>Unmatched Films:</h5>';
                unmatchedFilms.forEach(film => {
                    html += `<div class="letterboxd-film unmatched">✗ ${film.title}</div>`;
                });
            }
            
            filmsDiv.innerHTML = html;
            filmsDiv.style.display = 'block';
        }
        
        async function predictFromLetterboxd() {
            if (letterboxdMatchedIds.length === 0) {
                alert('No matched films available for recommendations');
                return;
            }
            
            try {
                document.getElementById('predictLetterboxdBtn').disabled = true;
                document.getElementById('predictLetterboxdBtn').textContent = 'Getting Recommendations...';
                
                // Use the matched IDs for prediction
                const recommendations = await generateRecommendations(letterboxdMatchedIds);
                displayRecommendations(recommendations, 'letterboxdRecommendations');
                
            } catch (error) {
                console.error('Prediction error:', error);
                alert(`Prediction error: ${error.message}`);
            } finally {
                document.getElementById('predictLetterboxdBtn').disabled = false;
                document.getElementById('predictLetterboxdBtn').textContent = 'Get Recommendations';
            }
        }
        
        async function predict() {
            if (!session || !metadata) {
                alert('Model not loaded yet!');
                return;
            }
            
            const movieInput = document.getElementById('movieInput').value.trim();
            if (!movieInput) {
                alert('Please enter movie IDs');
                return;
            }
            
            try {
                // Parse input
                const movieIds = movieInput.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
                
                if (movieIds.length === 0) {
                    alert('Please enter valid movie IDs');
                    return;
                }
                
                document.getElementById('predictBtn').disabled = true;
                document.getElementById('predictBtn').textContent = 'Predicting...';
                
                const recommendations = await generateRecommendations(movieIds);
                displayRecommendations(recommendations, 'recommendations');
                
            } catch (error) {
                console.error('Prediction error:', error);
                alert(`Prediction error: ${error.message}`);
            } finally {
                document.getElementById('predictBtn').disabled = false;
                document.getElementById('predictBtn').textContent = 'Get Recommendations';
            }
        }
        
        async function generateRecommendations(movieIds) {
            // Prepare input sequence with LEFT-PADDING like Python
            const maxLen = metadata.model_params.max_len;
            const inputSequence = new Array(maxLen).fill(0);
            
            // Left-pad: put movies at the END of the sequence
            const startIndex = Math.max(0, maxLen - movieIds.length);
            for (let i = 0; i < Math.min(movieIds.length, maxLen); i++) {
                inputSequence[startIndex + i] = movieIds[i];
            }
            
            console.log('Input sequence:', inputSequence);
            console.log('Input movies:', movieIds.map(id => `${id}: ${getMovieName(id)}`));
            
            // Create tensor - use regular Int32Array instead of BigInt64Array
            const inputTensor = new ort.Tensor('int64', new BigInt64Array(inputSequence.map(x => BigInt(x))), [1, maxLen]);
            
            console.log('Input tensor created:', inputTensor);
            
            // Run inference
            const results = await session.run({ input_sequence: inputTensor });
            const outputData = results.output_logits.data;
            
            console.log('Prediction completed, output shape:', results.output_logits.dims);
            
            // Get top recommendations
            return getTopRecommendations(outputData, movieIds, 10);
        }
        
        function getTopRecommendations(outputData, watchedMovies, topK) {
            // Convert to regular array and get movie scores
            const scores = Array.from(outputData);
            const watchedSet = new Set(watchedMovies);
            
            console.log('Output scores length:', scores.length);
            console.log('Watched movies:', watchedMovies);
            
            // Create (movieId, score) pairs, excluding watched movies and movie ID 0 (padding)
            const movieScores = [];
            for (let i = 1; i < scores.length; i++) {
                if (!watchedSet.has(i)) {
                    movieScores.push({ movieId: i, score: scores[i] });
                }
            }
            
            // Sort by score descending and take top K
            movieScores.sort((a, b) => b.score - a.score);
            
            console.log('Top 5 scores:', movieScores.slice(0, 5));
            
            return movieScores.slice(0, topK);
        }
        
        function displayRecommendations(recommendations, containerId) {
            const recDiv = document.getElementById(containerId);
            
            if (recommendations.length === 0) {
                recDiv.innerHTML = '<p>No recommendations found.</p>';
                return;
            }
            
            let html = '<h4>Top Recommendations:</h4>';
            recommendations.forEach((rec, index) => {
                const movieName = getMovieName(rec.movieId);
                html += `
                    <div class="movie-item">
                        <div class="movie-title">#${index + 1} - ${movieName}</div>
                        <div class="movie-id">Movie ID: ${rec.movieId}</div>
                        <div class="movie-score">Confidence Score: ${rec.score.toFixed(4)}</div>
                    </div>
                `;
            });
            
            recDiv.innerHTML = html;
        }
        
        // Start initialization when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>